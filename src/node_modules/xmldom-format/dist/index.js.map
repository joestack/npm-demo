{
  "version": 3,
  "sources": ["../src/index.ts", "../src/serializer/xmlEncoder.ts", "../src/serializer/attributeNodeSerializer.ts", "../src/serializer/cdataSectionSerializer.ts", "../src/utils/formatOptionUtils.ts", "../src/utils/nodeUtils.ts", "../src/serializer/commentNodeSerializer.ts", "../src/serializer/documentNodeSerializer.ts", "../src/serializer/documentTypeSerializer.ts", "../src/serializer/textNodeSerializer.ts", "../src/serializer/elementNodeSerializer.ts", "../src/serializer/entityReferenceSerializer.ts", "../src/serializer/processingInstructionSerializer.ts", "../src/serializer/unknownSerializer.ts", "../src/formatXml.ts", "../src/xmlSerializer.ts"],
  "sourcesContent": ["export * from './formatXml';\nexport * from './xmlSerializer';\n", "export function xmlEncoder(c: string) {\n  return (\n    (c === '<' && '&lt;') ||\n    (c === '>' && '&gt;') ||\n    (c === '&' && '&amp;') ||\n    (c === '\"' && '&quot;') ||\n    `&#${c.charCodeAt(0)};`\n  );\n}\n", "import { NodeType } from '../models';\nimport { xmlEncoder } from './xmlEncoder';\n\nexport function addSerializedAttribute(qualifiedName: string, value: string): Array<string> {\n  return [' ', qualifiedName, '=\"', value.replace(/[<>&\"\\t\\n\\r]/gu, xmlEncoder), '\"'];\n}\n\nexport function serializeAttributeNode(node: Node): Array<string> | undefined {\n  if (isAttributeNode(node)) {\n    return addSerializedAttribute(node.name, node.value);\n  }\n  return undefined;\n}\n\nfunction isAttributeNode(node: Node): node is Attr {\n  return node.nodeType === NodeType.ATTRIBUTE_NODE;\n}\n", "import { NodeType } from '../models';\n\nexport function isCDataSectionNode(node: Node): node is Text {\n  return node.nodeType === NodeType.CDATA_SECTION_NODE;\n}\nexport function serializeCDataSectionNode(node: Node): Array<string> | undefined {\n  if (isCDataSectionNode(node)) {\n    return ['<![CDATA[', node.data, ']]>'];\n  }\n  return undefined;\n}\n", "import { SerializerContext } from '../models';\n\nexport function addIndentation(buffer: string[], context: SerializerContext) {\n  if (context.formatOptions?.indentation) {\n    buffer.push(context.formatOptions.eol || `\\r\\n`);\n    for (let index = 0; index < context.level; index++) {\n      buffer.push(context.formatOptions.indentation);\n    }\n  }\n}\n\nexport function addWhitespaceInAutoClosingNode(buffer: string[], context: SerializerContext) {\n  if (context.formatOptions?.useWhitespaceInAutoClosingNode) {\n    buffer.push(' ');\n  }\n}\n", "import { SerializerContext } from '../models';\n\nexport function isCharacterData(node: Node): node is CharacterData {\n  return !!(node as CharacterData).data;\n}\n\nexport function isInlineElement(node: Node, context: SerializerContext) {\n  const inlineElements = context.formatOptions?.inlineElements || DefaultInlineElements;\n  return inlineElements.indexOf(node.nodeName) >= 0;\n}\n\nconst DefaultInlineElements = [\n  'a',\n  'abbr',\n  'acronym',\n  'audio',\n  'b',\n  'bdi',\n  'bdo',\n  'big',\n  'br',\n  'button',\n  'canvas',\n  'cite',\n  'code',\n  'data',\n  'datalist',\n  'del',\n  'dfn',\n  'em',\n  'embed',\n  'i',\n  'iframe',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'label',\n  'map',\n  'mark',\n  'meter',\n  'noscript',\n  'object',\n  'output',\n  'picture',\n  'progress',\n  'q',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'select',\n  'slot',\n  'small',\n  'span',\n  'strong',\n  'sub',\n  'sup',\n  'svg',\n  'template',\n  'textarea',\n  'time',\n  'u',\n  'tt',\n  'var',\n  'video',\n  'wbr',\n];\n", "import { NodeType, SerializerContext } from '../models';\nimport { addIndentation } from '../utils';\n\nfunction isCommentNode(node: Node): node is Comment {\n  return node.nodeType === NodeType.COMMENT_NODE;\n}\n\nexport function serializeCommentNode(node: Node, context: SerializerContext): Array<string> | undefined {\n  if (isCommentNode(node)) {\n    const buffer: Array<string> = [];\n    addIndentation(buffer, context);\n    buffer.push('<!--', node.data, '-->');\n    return buffer;\n  }\n  return undefined;\n}\n", "import { NodeType, SerializerContext } from '../models';\n\nexport function isDocumentNode(node: Node): node is Document {\n  return node.nodeType === NodeType.DOCUMENT_NODE;\n}\nfunction isDocumentFragment(node: Node): node is DocumentFragment {\n  return node.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE;\n}\n\nexport function serializeDocumentNode(node: Node, context: SerializerContext) {\n  if (isDocumentNode(node) || isDocumentFragment(node)) {\n    const buffer: Array<string> = [];\n    let child = node.firstChild;\n    while (child) {\n      buffer.push(...context.serializeNode(child, context));\n      child = child.nextSibling;\n    }\n    return buffer;\n  }\n  return undefined;\n}\n", "import { NodeType, SerializerContext } from '../models';\nimport { addIndentation } from '../utils';\n\nexport function serializeDocumentType(node: Node, context: SerializerContext): Array<string> | undefined {\n  if (isDocumentType(node)) {\n    const buffer: Array<string> = [];\n    addIndentation(buffer, context);\n    buffer.push('<!DOCTYPE ', node.name);\n    if (node.publicId) {\n      buffer.push(' PUBLIC ', node.publicId);\n      if (node.systemId && node.systemId !== '.') {\n        buffer.push(' ', node.systemId);\n      }\n      buffer.push('>');\n    } else if (node.systemId && node.systemId !== '.') {\n      buffer.push(' SYSTEM ', node.systemId, '>');\n    } else {\n      if (node.internalSubset) {\n        buffer.push(' [', node.internalSubset, ']');\n      }\n      buffer.push('>');\n    }\n    return buffer;\n  }\n  return undefined;\n}\n\nfunction isDocumentType(node: Node): node is DocumentType & { internalSubset?: string } {\n  return node.nodeType === NodeType.DOCUMENT_TYPE_NODE;\n}\n", "import { NodeType } from '../models';\nimport { xmlEncoder } from './xmlEncoder';\n\n/**\n * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,\n * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.\n * If they are needed elsewhere, they must be escaped using either numeric character references or the strings\n * `&amp;` and `&lt;` respectively.\n * The right angle bracket (>) may be represented using the string \" &gt; \", and must, for compatibility,\n * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,\n * when that string is not marking the end of a CDATA section.\n *\n * In the content of elements, character data is any string of characters\n * which does not contain the start-delimiter of any markup\n * and does not include the CDATA-section-close delimiter, `]]>`.\n *\n * @see https://www.w3.org/TR/xml/#NT-CharData\n * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node\n */\nexport function serializeTextNode(node: Node): Array<string> | undefined {\n  if (isTextNode(node)) {\n    return [node.data.trim().replace(/[<&>]/gu, xmlEncoder)];\n  }\n  return undefined;\n}\n\nexport function isTextNode(node: Node): node is CharacterData {\n  return node.nodeType === NodeType.TEXT_NODE;\n}\n", "import { NodeType, Namespace, SerializerContext } from '../models';\nimport { addIndentation, addWhitespaceInAutoClosingNode, isCharacterData, isInlineElement } from '../utils';\nimport { addSerializedAttribute } from './attributeNodeSerializer';\nimport { isCDataSectionNode } from './cdataSectionSerializer';\nimport { isTextNode } from './textNodeSerializer';\n\nexport function serializeElementNode(node: Node, context: SerializerContext): Array<string> | undefined {\n  if (isElementNode(node)) {\n    const buffer: Array<string> = [];\n\n    const attrs = node.attributes;\n    const len = attrs.length;\n    const nodeName = node.tagName;\n\n    context.isHtml = node.namespaceURI === 'http://www.w3.org/1999/xhtml' || context.isHtml;\n\n    let prefixedNodeName = nodeName;\n    if (!context.isHtml && !node.prefix && node.namespaceURI) {\n      let defaultNS;\n      // lookup current default ns from `xmlns` attribute\n      for (let ai = 0; ai < attrs.length; ai++) {\n        if (attrs.item(ai)?.name === 'xmlns') {\n          defaultNS = attrs.item(ai)?.value;\n          break;\n        }\n      }\n      if (!defaultNS) {\n        // lookup current default ns in visibleNamespaces\n        for (let nsi = context.visibleNamespaces.length - 1; nsi >= 0; nsi--) {\n          const namespace = context.visibleNamespaces[nsi];\n          if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {\n            defaultNS = namespace.namespace;\n            break;\n          }\n        }\n      }\n      if (defaultNS !== node.namespaceURI) {\n        for (let nsi = context.visibleNamespaces.length - 1; nsi >= 0; nsi--) {\n          const namespace = context.visibleNamespaces[nsi];\n          if (namespace.namespace === node.namespaceURI) {\n            if (namespace.prefix) {\n              prefixedNodeName = `${namespace.prefix}:${nodeName}`;\n            }\n            break;\n          }\n        }\n      }\n    }\n\n    if (!isInlineElement(node, context)) {\n      addIndentation(buffer, context);\n    }\n    buffer.push('<', prefixedNodeName);\n\n    for (let i = 0; i < len; i++) {\n      // add namespaces for attributes\n      const attr = attrs.item(i);\n      if (attr?.prefix === 'xmlns') {\n        context.visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });\n      } else if (attr?.nodeName === 'xmlns') {\n        context.visibleNamespaces.push({ prefix: '', namespace: attr.value });\n      }\n    }\n\n    for (let i = 0; i < len; i++) {\n      const attr = attrs.item(i);\n      if (attr) {\n        if (needNamespaceDefine(attr, context.visibleNamespaces) && attr.namespaceURI) {\n          const prefix = attr.prefix || '';\n          buffer.push(...addSerializedAttribute(prefix ? `xmlns:${prefix}` : 'xmlns', attr.namespaceURI));\n          context.visibleNamespaces.push({ prefix, namespace: attr.namespaceURI });\n        }\n        buffer.push(...context.serializeNode(attr, context));\n      }\n    }\n\n    // add namespace for current node\n    if (nodeName === prefixedNodeName && needNamespaceDefine(node, context.visibleNamespaces)) {\n      if (node.namespaceURI) {\n        const prefix = node.prefix || '';\n        buffer.push(...addSerializedAttribute(prefix ? `xmlns:${prefix}` : 'xmlns', node.namespaceURI));\n        context.visibleNamespaces.push({ prefix, namespace: node.namespaceURI });\n      }\n    }\n\n    if (node.firstChild || (context.isHtml && !/^(?:meta|link|img|br|hr|input)$/iu.test(nodeName))) {\n      buffer.push('>');\n\n      let child = node.firstChild;\n      // if is cdata child node\n      let onlyInlineElements = true;\n      const isScriptNode = context.isHtml && /^script$/iu.test(nodeName);\n      while (child) {\n        if (isScriptNode && isCharacterData(child) && child.data) {\n          buffer.push(child.data);\n        } else {\n          if (!isTextNode(child) && !isCDataSectionNode(child) && !isInlineElement(child, context)) {\n            onlyInlineElements = false;\n          }\n          buffer.push(...context.serializeNode(child, { ...context, level: context.level + 1 }));\n        }\n        child = child.nextSibling;\n      }\n\n      if (!onlyInlineElements) {\n        addIndentation(buffer, context);\n      }\n      buffer.push('</', prefixedNodeName, '>');\n    } else {\n      addWhitespaceInAutoClosingNode(buffer, context);\n      buffer.push('/>');\n    }\n    return buffer;\n  }\n  return undefined;\n}\n\nfunction needNamespaceDefine(node: Attr | Element, visibleNamespaces: Array<Namespace>) {\n  const prefix = node.prefix || '';\n  const uri = node.namespaceURI;\n  // According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,\n  // and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :\n  // > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.\n  // in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)\n  // and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :\n  // > [...] Furthermore, the attribute value [...] must not be an empty string.\n  // so serializing empty namespace value like xmlns:ds=\"\" would produce an invalid XML document.\n  if (!uri) {\n    return false;\n  }\n  if ((prefix === 'xml' && uri === 'http://www.w3.org/XML/1998/namespace') || uri === 'http://www.w3.org/2000/xmlns/') {\n    return false;\n  }\n\n  let i = visibleNamespaces.length;\n  while (i--) {\n    const ns = visibleNamespaces[i];\n    // get namespace prefix\n    if (ns.prefix === prefix) {\n      return ns.namespace !== uri;\n    }\n  }\n  return true;\n}\n\nfunction isElementNode(node: Node): node is Element {\n  return node.nodeType === NodeType.ELEMENT_NODE;\n}\n", "import { NodeType } from '../models';\n\nexport function serializeEntityReferenceNode(node: Node): Array<string> | undefined {\n  if (node.nodeType === NodeType.ENTITY_REFERENCE_NODE) {\n    return ['&', node.nodeName, ';'];\n  }\n  return undefined;\n}\n", "import { NodeType, SerializerContext } from '../models';\nimport { addIndentation } from '../utils';\n\nfunction isProcessingInstructionNode(node: Node): node is ProcessingInstruction {\n  return node.nodeType === NodeType.PROCESSING_INSTRUCTION_NODE;\n}\n\nexport function serializeProcessingInstructionNode(node: Node, context: SerializerContext): Array<string> | undefined {\n  if (isProcessingInstructionNode(node)) {\n    const buffer: Array<string> = [];\n    addIndentation(buffer, context);\n    buffer.push('<?', node.target, ' ', node.data, '?>');\n    return buffer;\n  }\n  return undefined;\n}\n", "export function serializeUnknownNode(node: Node) {\n  return ['??', node.nodeName];\n}\n", "import { FormatOptions, SerializerContext, SerializerFunction } from './models';\nimport * as serializer from './serializer';\n\nexport function formatXml(node: Node, formatOptions?: FormatOptions) {\n  const context: SerializerContext = {\n    isHtml: false,\n    visibleNamespaces: [],\n    serializeNode,\n    level: 0,\n    formatOptions,\n  };\n\n  if (serializer.isDocumentNode(node) && node.documentElement && !node.documentElement.prefix) {\n    const prefix = node.documentElement.lookupPrefix(node.documentElement.namespaceURI);\n    if (!prefix) {\n      context.visibleNamespaces.push({\n        prefix: null,\n        namespace: node.documentElement.namespaceURI,\n      });\n    }\n  }\n  const buffer = serializeNode(node, context);\n  return buffer.join('').trim();\n}\n\nconst serializers: Array<SerializerFunction> = [\n  serializer.serializeElementNode,\n  serializer.serializeDocumentNode,\n  serializer.serializeAttributeNode,\n  serializer.serializeTextNode,\n  serializer.serializeCDataSectionNode,\n  serializer.serializeCommentNode,\n  serializer.serializeDocumentType,\n  serializer.serializeProcessingInstructionNode,\n  serializer.serializeEntityReferenceNode,\n  serializer.serializeUnknownNode,\n];\n\nfunction serializeNode(node: Node, context: SerializerContext): Array<string> {\n  const contextClone = {\n    ...context,\n    visibleNamespaces: context.visibleNamespaces.slice(),\n  };\n  const buffer: Array<string> = [];\n  for (const serializer of serializers) {\n    const result = serializer(node, contextClone);\n    if (result) {\n      buffer.push(...result);\n      return buffer;\n    }\n  }\n  return buffer;\n}\n", "import { formatXml } from './formatXml';\nimport { FormatOptions } from './models';\n\nexport class XMLSerializer {\n  constructor(private readonly formatOptions?: FormatOptions) {}\n  serializeToString(node: Node) {\n    return formatXml(node, this.formatOptions);\n  }\n}\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,mBAAAE,EAAA,cAAAC,IAAA,eAAAC,EAAAJ,GCAO,SAASK,EAAWC,EAAW,CACpC,OACGA,IAAM,KAAO,QACbA,IAAM,KAAO,QACbA,IAAM,KAAO,SACbA,IAAM,KAAO,UACd,KAAKA,EAAE,WAAW,CAAC,IAEvB,CCLO,SAASC,EAAuBC,EAAuBC,EAA8B,CAC1F,MAAO,CAAC,IAAKD,EAAe,KAAMC,EAAM,QAAQ,iBAAkBC,CAAU,EAAG,GAAG,CACpF,CAEO,SAASC,EAAuBC,EAAuC,CAC5E,GAAIC,EAAgBD,CAAI,EACtB,OAAOL,EAAuBK,EAAK,KAAMA,EAAK,KAAK,CAGvD,CAEA,SAASC,EAAgBD,EAA0B,CACjD,OAAOA,EAAK,WAAa,CAC3B,CCdO,SAASE,EAAmBC,EAA0B,CAC3D,OAAOA,EAAK,WAAa,CAC3B,CACO,SAASC,EAA0BD,EAAuC,CAC/E,GAAID,EAAmBC,CAAI,EACzB,MAAO,CAAC,YAAaA,EAAK,KAAM,KAAK,CAGzC,CCRO,SAASE,EAAeC,EAAkBC,EAA4B,CAC3E,GAAIA,EAAQ,eAAe,YAAa,CACtCD,EAAO,KAAKC,EAAQ,cAAc,KAAO;AAAA,CAAM,EAC/C,QAASC,EAAQ,EAAGA,EAAQD,EAAQ,MAAOC,IACzCF,EAAO,KAAKC,EAAQ,cAAc,WAAW,CAEjD,CACF,CAEO,SAASE,EAA+BH,EAAkBC,EAA4B,CACvFA,EAAQ,eAAe,gCACzBD,EAAO,KAAK,GAAG,CAEnB,CCbO,SAASI,EAAgBC,EAAmC,CACjE,MAAO,CAAC,CAAEA,EAAuB,IACnC,CAEO,SAASC,EAAgBD,EAAYE,EAA4B,CAEtE,OADuBA,EAAQ,eAAe,gBAAkBC,GAC1C,QAAQH,EAAK,QAAQ,GAAK,CAClD,CAEA,IAAMG,EAAwB,CAC5B,IACA,OACA,UACA,QACA,IACA,MACA,MACA,MACA,KACA,SACA,SACA,OACA,OACA,OACA,WACA,MACA,MACA,KACA,QACA,IACA,SACA,MACA,QACA,MACA,MACA,QACA,MACA,OACA,QACA,WACA,SACA,SACA,UACA,WACA,IACA,OACA,IACA,OACA,SACA,SACA,OACA,QACA,OACA,SACA,MACA,MACA,MACA,WACA,WACA,OACA,IACA,KACA,MACA,QACA,KACF,EChEA,SAASC,EAAcC,EAA6B,CAClD,OAAOA,EAAK,WAAa,CAC3B,CAEO,SAASC,EAAqBD,EAAYE,EAAuD,CACtG,GAAIH,EAAcC,CAAI,EAAG,CACvB,IAAMG,EAAwB,CAAC,EAC/B,OAAAC,EAAeD,EAAQD,CAAO,EAC9BC,EAAO,KAAK,OAAQH,EAAK,KAAM,KAAK,EAC7BG,CACT,CAEF,CCbO,SAASE,EAAeC,EAA8B,CAC3D,OAAOA,EAAK,WAAa,CAC3B,CACA,SAASC,EAAmBD,EAAsC,CAChE,OAAOA,EAAK,WAAa,EAC3B,CAEO,SAASE,EAAsBF,EAAYG,EAA4B,CAC5E,GAAIJ,EAAeC,CAAI,GAAKC,EAAmBD,CAAI,EAAG,CACpD,IAAMI,EAAwB,CAAC,EAC3BC,EAAQL,EAAK,WACjB,KAAOK,GACLD,EAAO,KAAK,GAAGD,EAAQ,cAAcE,EAAOF,CAAO,CAAC,EACpDE,EAAQA,EAAM,YAEhB,OAAOD,CACT,CAEF,CCjBO,SAASE,EAAsBC,EAAYC,EAAuD,CACvG,GAAIC,EAAeF,CAAI,EAAG,CACxB,IAAMG,EAAwB,CAAC,EAC/B,OAAAC,EAAeD,EAAQF,CAAO,EAC9BE,EAAO,KAAK,aAAcH,EAAK,IAAI,EAC/BA,EAAK,UACPG,EAAO,KAAK,WAAYH,EAAK,QAAQ,EACjCA,EAAK,UAAYA,EAAK,WAAa,KACrCG,EAAO,KAAK,IAAKH,EAAK,QAAQ,EAEhCG,EAAO,KAAK,GAAG,GACNH,EAAK,UAAYA,EAAK,WAAa,IAC5CG,EAAO,KAAK,WAAYH,EAAK,SAAU,GAAG,GAEtCA,EAAK,gBACPG,EAAO,KAAK,KAAMH,EAAK,eAAgB,GAAG,EAE5CG,EAAO,KAAK,GAAG,GAEVA,CACT,CAEF,CAEA,SAASD,EAAeF,EAAgE,CACtF,OAAOA,EAAK,WAAa,EAC3B,CCVO,SAASK,EAAkBC,EAAuC,CACvE,GAAIC,EAAWD,CAAI,EACjB,MAAO,CAACA,EAAK,KAAK,KAAK,EAAE,QAAQ,UAAWE,CAAU,CAAC,CAG3D,CAEO,SAASD,EAAWD,EAAmC,CAC5D,OAAOA,EAAK,WAAa,CAC3B,CCtBO,SAASG,EAAqBC,EAAYC,EAAuD,CACtG,GAAIC,EAAcF,CAAI,EAAG,CACvB,IAAMG,EAAwB,CAAC,EAEzBC,EAAQJ,EAAK,WACbK,EAAMD,EAAM,OACZE,EAAWN,EAAK,QAEtBC,EAAQ,OAASD,EAAK,eAAiB,gCAAkCC,EAAQ,OAEjF,IAAIM,EAAmBD,EACvB,GAAI,CAACL,EAAQ,QAAU,CAACD,EAAK,QAAUA,EAAK,aAAc,CACxD,IAAIQ,EAEJ,QAASC,EAAK,EAAGA,EAAKL,EAAM,OAAQK,IAClC,GAAIL,EAAM,KAAKK,CAAE,GAAG,OAAS,QAAS,CACpCD,EAAYJ,EAAM,KAAKK,CAAE,GAAG,MAC5B,KACF,CAEF,GAAI,CAACD,EAEH,QAASE,EAAMT,EAAQ,kBAAkB,OAAS,EAAGS,GAAO,EAAGA,IAAO,CACpE,IAAMC,EAAYV,EAAQ,kBAAkBS,CAAG,EAC/C,GAAIC,EAAU,SAAW,IAAMA,EAAU,YAAcX,EAAK,aAAc,CACxEQ,EAAYG,EAAU,UACtB,KACF,CACF,CAEF,GAAIH,IAAcR,EAAK,aACrB,QAASU,EAAMT,EAAQ,kBAAkB,OAAS,EAAGS,GAAO,EAAGA,IAAO,CACpE,IAAMC,EAAYV,EAAQ,kBAAkBS,CAAG,EAC/C,GAAIC,EAAU,YAAcX,EAAK,aAAc,CACzCW,EAAU,SACZJ,EAAmB,GAAGI,EAAU,UAAUL,KAE5C,KACF,CACF,CAEJ,CAEKM,EAAgBZ,EAAMC,CAAO,GAChCY,EAAeV,EAAQF,CAAO,EAEhCE,EAAO,KAAK,IAAKI,CAAgB,EAEjC,QAASO,EAAI,EAAGA,EAAIT,EAAKS,IAAK,CAE5B,IAAMC,EAAOX,EAAM,KAAKU,CAAC,EACrBC,GAAM,SAAW,QACnBd,EAAQ,kBAAkB,KAAK,CAAE,OAAQc,EAAK,UAAW,UAAWA,EAAK,KAAM,CAAC,EACvEA,GAAM,WAAa,SAC5Bd,EAAQ,kBAAkB,KAAK,CAAE,OAAQ,GAAI,UAAWc,EAAK,KAAM,CAAC,CAExE,CAEA,QAASD,EAAI,EAAGA,EAAIT,EAAKS,IAAK,CAC5B,IAAMC,EAAOX,EAAM,KAAKU,CAAC,EACzB,GAAIC,EAAM,CACR,GAAIC,EAAoBD,EAAMd,EAAQ,iBAAiB,GAAKc,EAAK,aAAc,CAC7E,IAAME,EAASF,EAAK,QAAU,GAC9BZ,EAAO,KAAK,GAAGe,EAAuBD,EAAS,SAASA,IAAW,QAASF,EAAK,YAAY,CAAC,EAC9Fd,EAAQ,kBAAkB,KAAK,CAAE,OAAAgB,EAAQ,UAAWF,EAAK,YAAa,CAAC,CACzE,CACAZ,EAAO,KAAK,GAAGF,EAAQ,cAAcc,EAAMd,CAAO,CAAC,CACrD,CACF,CAGA,GAAIK,IAAaC,GAAoBS,EAAoBhB,EAAMC,EAAQ,iBAAiB,GAClFD,EAAK,aAAc,CACrB,IAAMiB,EAASjB,EAAK,QAAU,GAC9BG,EAAO,KAAK,GAAGe,EAAuBD,EAAS,SAASA,IAAW,QAASjB,EAAK,YAAY,CAAC,EAC9FC,EAAQ,kBAAkB,KAAK,CAAE,OAAAgB,EAAQ,UAAWjB,EAAK,YAAa,CAAC,CACzE,CAGF,GAAIA,EAAK,YAAeC,EAAQ,QAAU,CAAC,oCAAoC,KAAKK,CAAQ,EAAI,CAC9FH,EAAO,KAAK,GAAG,EAEf,IAAIgB,EAAQnB,EAAK,WAEboB,EAAqB,GACnBC,EAAepB,EAAQ,QAAU,aAAa,KAAKK,CAAQ,EACjE,KAAOa,GACDE,GAAgBC,EAAgBH,CAAK,GAAKA,EAAM,KAClDhB,EAAO,KAAKgB,EAAM,IAAI,GAElB,CAACI,EAAWJ,CAAK,GAAK,CAACK,EAAmBL,CAAK,GAAK,CAACP,EAAgBO,EAAOlB,CAAO,IACrFmB,EAAqB,IAEvBjB,EAAO,KAAK,GAAGF,EAAQ,cAAckB,EAAO,CAAE,GAAGlB,EAAS,MAAOA,EAAQ,MAAQ,CAAE,CAAC,CAAC,GAEvFkB,EAAQA,EAAM,YAGXC,GACHP,EAAeV,EAAQF,CAAO,EAEhCE,EAAO,KAAK,KAAMI,EAAkB,GAAG,CACzC,MACEkB,EAA+BtB,EAAQF,CAAO,EAC9CE,EAAO,KAAK,IAAI,EAElB,OAAOA,CACT,CAEF,CAEA,SAASa,EAAoBhB,EAAsB0B,EAAqC,CACtF,IAAMT,EAASjB,EAAK,QAAU,GACxB2B,EAAM3B,EAAK,aAWjB,GAHI,CAAC2B,GAGAV,IAAW,OAASU,IAAQ,wCAA2CA,IAAQ,gCAClF,MAAO,GAGT,IAAIb,EAAIY,EAAkB,OAC1B,KAAOZ,KAAK,CACV,IAAMc,EAAKF,EAAkBZ,CAAC,EAE9B,GAAIc,EAAG,SAAWX,EAChB,OAAOW,EAAG,YAAcD,CAE5B,CACA,MAAO,EACT,CAEA,SAASzB,EAAcF,EAA6B,CAClD,OAAOA,EAAK,WAAa,CAC3B,CCjJO,SAAS6B,EAA6BC,EAAuC,CAClF,GAAIA,EAAK,WAAa,EACpB,MAAO,CAAC,IAAKA,EAAK,SAAU,GAAG,CAGnC,CCJA,SAASC,EAA4BC,EAA2C,CAC9E,OAAOA,EAAK,WAAa,CAC3B,CAEO,SAASC,EAAmCD,EAAYE,EAAuD,CACpH,GAAIH,EAA4BC,CAAI,EAAG,CACrC,IAAMG,EAAwB,CAAC,EAC/B,OAAAC,EAAeD,EAAQD,CAAO,EAC9BC,EAAO,KAAK,KAAMH,EAAK,OAAQ,IAAKA,EAAK,KAAM,IAAI,EAC5CG,CACT,CAEF,CCfO,SAASE,EAAqBC,EAAY,CAC/C,MAAO,CAAC,KAAMA,EAAK,QAAQ,CAC7B,CCCO,SAASC,EAAUC,EAAYC,EAA+B,CACnE,IAAMC,EAA6B,CACjC,OAAQ,GACR,kBAAmB,CAAC,EACpB,cAAAC,EACA,MAAO,EACP,cAAAF,CACF,EAEA,OAAeG,EAAeJ,CAAI,GAAKA,EAAK,iBAAmB,CAACA,EAAK,gBAAgB,SACpEA,EAAK,gBAAgB,aAAaA,EAAK,gBAAgB,YAAY,GAEhFE,EAAQ,kBAAkB,KAAK,CAC7B,OAAQ,KACR,UAAWF,EAAK,gBAAgB,YAClC,CAAC,GAGUG,EAAcH,EAAME,CAAO,EAC5B,KAAK,EAAE,EAAE,KAAK,CAC9B,CAEA,IAAMG,EAAyC,CAClCC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,CACb,EAEA,SAASZ,EAAcH,EAAYE,EAA2C,CAC5E,IAAMc,EAAe,CACnB,GAAGd,EACH,kBAAmBA,EAAQ,kBAAkB,MAAM,CACrD,EACMe,EAAwB,CAAC,EAC/B,QAAWC,KAAcb,EAAa,CACpC,IAAMc,EAASD,EAAWlB,EAAMgB,CAAY,EAC5C,GAAIG,EACF,OAAAF,EAAO,KAAK,GAAGE,CAAM,EACdF,CAEX,CACA,OAAOA,CACT,CCjDO,IAAMG,EAAN,KAAoB,CACzB,YAA6BC,EAA+B,CAA/B,mBAAAA,CAAgC,CAC7D,kBAAkBC,EAAY,CAC5B,OAAOC,EAAUD,EAAM,KAAK,aAAa,CAC3C,CACF",
  "names": ["src_exports", "__export", "XMLSerializer", "formatXml", "__toCommonJS", "xmlEncoder", "c", "addSerializedAttribute", "qualifiedName", "value", "xmlEncoder", "serializeAttributeNode", "node", "isAttributeNode", "isCDataSectionNode", "node", "serializeCDataSectionNode", "addIndentation", "buffer", "context", "index", "addWhitespaceInAutoClosingNode", "isCharacterData", "node", "isInlineElement", "context", "DefaultInlineElements", "isCommentNode", "node", "serializeCommentNode", "context", "buffer", "addIndentation", "isDocumentNode", "node", "isDocumentFragment", "serializeDocumentNode", "context", "buffer", "child", "serializeDocumentType", "node", "context", "isDocumentType", "buffer", "addIndentation", "serializeTextNode", "node", "isTextNode", "xmlEncoder", "serializeElementNode", "node", "context", "isElementNode", "buffer", "attrs", "len", "nodeName", "prefixedNodeName", "defaultNS", "ai", "nsi", "namespace", "isInlineElement", "addIndentation", "i", "attr", "needNamespaceDefine", "prefix", "addSerializedAttribute", "child", "onlyInlineElements", "isScriptNode", "isCharacterData", "isTextNode", "isCDataSectionNode", "addWhitespaceInAutoClosingNode", "visibleNamespaces", "uri", "ns", "serializeEntityReferenceNode", "node", "isProcessingInstructionNode", "node", "serializeProcessingInstructionNode", "context", "buffer", "addIndentation", "serializeUnknownNode", "node", "formatXml", "node", "formatOptions", "context", "serializeNode", "isDocumentNode", "serializers", "serializeElementNode", "serializeDocumentNode", "serializeAttributeNode", "serializeTextNode", "serializeCDataSectionNode", "serializeCommentNode", "serializeDocumentType", "serializeProcessingInstructionNode", "serializeEntityReferenceNode", "serializeUnknownNode", "contextClone", "buffer", "serializer", "result", "XMLSerializer", "formatOptions", "node", "formatXml"]
}
