{
  "version": 3,
  "sources": ["../src/index.ts", "../src/models/hookCancel.ts", "../src/hooks/sortSet.ts", "../src/hooks/hook.ts", "../src/hooks/lastOutHook.ts", "../src/hooks/seriesHook.ts", "../src/hooks/waterfallHook.ts"],
  "sourcesContent": ["export * from './models';\nexport * from './hooks';\n", "export const HookCancel = Symbol.for('HookCancel');\n", "interface SortItem<T> {\n  id: string;\n  after: Array<SortItem<T>>;\n  item: T;\n  index?: number;\n}\n\nexport class SortSet<T extends { id: string; before?: Array<string>; after?: Array<string> }> {\n  private items: Set<T>;\n  private sortedItems: Array<T> | undefined;\n\n  constructor() {\n    this.items = new Set();\n  }\n\n  hasItem(id: string) {\n    return Array.from(this.items).some(obj => obj.id === id);\n  }\n\n  add(...items: Array<T>) {\n    for (const item of items) {\n      this.ensureUniqueId(item);\n      this.items.add(item);\n    }\n    this.sortedItems = undefined;\n  }\n\n  private ensureUniqueId(item: T) {\n    if (!item.id) {\n      item.id = 'unknown';\n    }\n    const id = item.id;\n    let index = 1;\n    while (Array.from(this.items).some(obj => obj.id === item.id && obj !== item)) {\n      item.id = `${id}#${index++}`;\n    }\n  }\n\n  addSortSet(set: SortSet<T>) {\n    for (const item of set.items) {\n      this.ensureUniqueId(item);\n      this.items.add(item);\n    }\n    this.sortedItems = undefined;\n  }\n  remove(id: string) {\n    const item = Array.from(this.items).find(obj => obj.id === id);\n    if (item) {\n      this.items.delete(item);\n      this.sortedItems = undefined;\n      return true;\n    }\n    return false;\n  }\n\n  public get sorted() {\n    if (!this.sortedItems) {\n      const sortItems = this.calculateIndex(this.prepareSortItems());\n      this.sortedItems = sortItems\n        .sort((obj1, obj2) => {\n          if (obj1.index < obj2.index) {\n            return -1;\n          }\n          if (obj1.index > obj2.index) {\n            return 1;\n          }\n          return 0;\n        })\n        .map(obj => obj.item);\n    }\n    return this.sortedItems;\n  }\n\n  private prepareSortItems() {\n    const sortItems: Array<SortItem<T>> = [];\n    const sortMap: Map<string, SortItem<T>> = new Map(\n      Array.from(this.items).map(item => [item.id, { id: item.id, after: [], item }])\n    );\n\n    const beforeItems: Array<SortItem<T>> = [];\n    for (const item of this.items) {\n      const sortItem = sortMap.get(item.id);\n      if (sortItem) {\n        if (item.after) {\n          for (const afterId of item.after) {\n            const afterItem = sortMap.get(afterId);\n            if (afterItem) {\n              sortItem.after.push(afterItem);\n            }\n          }\n        }\n        if (item.before) {\n          beforeItems.push(sortItem);\n        } else {\n          sortItems.push(sortItem);\n        }\n      }\n    }\n    for (const sortItem of beforeItems) {\n      const index = [];\n      if (sortItem.item.before) {\n        for (const beforeId of sortItem.item.before) {\n          const beforeItem = sortMap.get(beforeId);\n          if (beforeItem) {\n            beforeItem.after.splice(0, 0, sortItem);\n            index.push(sortItems.findIndex(obj => obj.id === beforeId));\n          }\n        }\n      }\n      sortItems.splice(Math.min(...index), 0, sortItem);\n    }\n    return sortItems;\n  }\n\n  private calculateIndex(sortItems: Array<SortItem<T>>) {\n    const result: Array<SortItem<T> & { index: number }> = [];\n    for (const sortItem of sortItems) {\n      result.push({\n        ...sortItem,\n        index: this.getIndex(sortItem, sortItems),\n      });\n    }\n    return result;\n  }\n\n  private getIndex(sortItem: SortItem<T>, sortItems: Array<SortItem<T>>): number {\n    if (typeof sortItem.index === 'undefined') {\n      if (sortItem.after.length === 0) {\n        sortItem.index = sortItems.indexOf(sortItem) * 2;\n      } else {\n        sortItem.index = -1;\n        const afterIndex = sortItem.after.map(obj => this.getIndex(obj, sortItems)).filter(obj => obj >= 0);\n        if (afterIndex.length > 0) {\n          sortItem.index = Math.max(...afterIndex) + 1;\n        }\n      }\n    }\n    return sortItem.index;\n  }\n}\n", "import { IHook, HookCancel, HookInterceptor, HookItem, HookTriggerContext } from '../models';\nimport { SortSet } from './sortSet';\n\nexport abstract class Hook<TArgs extends unknown[], TReturn, TResult> implements IHook<TArgs, TReturn, TResult> {\n  #items: SortSet<HookItem<TArgs, TReturn>>;\n  #interceptors: SortSet<HookInterceptor<TArgs, TReturn>>;\n\n  get interceptors(): ReadonlyArray<HookInterceptor<TArgs, TReturn>> {\n    return [...this.#interceptors.sorted];\n  }\n\n  get items(): ReadonlyArray<HookItem<TArgs, TReturn>> {\n    return [...this.#items.sorted];\n  }\n\n  id: string;\n\n  constructor(protected readonly bailOut?: ((arg: TReturn) => boolean) | undefined) {\n    this.id = this.constructor.name;\n    this.#items = new SortSet();\n    this.#interceptors = new SortSet();\n  }\n\n  hasHook(id: string) {\n    return this.#items.hasItem(id);\n  }\n\n  addHook(\n    id: string,\n    action: (...args: TArgs) => TReturn | typeof HookCancel | Promise<TReturn | typeof HookCancel>,\n    options?: {\n      before?: Array<string>;\n      after?: Array<string>;\n    }\n  ): void {\n    const item = {\n      ...options,\n      id,\n      action,\n    };\n    this.#items.add(item);\n  }\n\n  addObjHook<TObj extends Omit<HookItem<TArgs, TReturn>, 'action'>>(\n    getAction: (obj: TObj) => (...args: TArgs) => Promise<TReturn | typeof HookCancel>,\n    ...objs: TObj[]\n  ): void {\n    this.#items.add(\n      ...objs.map(obj => ({\n        ...obj,\n        id: obj.id,\n        action: (...args: TArgs) => getAction(obj).call(obj, ...args),\n      }))\n    );\n  }\n\n  removeHook(id: string): boolean {\n    return this.#items.remove(id);\n  }\n\n  addInterceptor(interceptor: HookInterceptor<TArgs, TReturn>): void {\n    this.#interceptors.add(interceptor);\n  }\n  removeInterceptor(id: string): boolean {\n    return this.#interceptors.remove(id);\n  }\n\n  public async trigger(...args: TArgs): Promise<TResult | typeof HookCancel> {\n    const results: TReturn[] = [];\n    const context: HookTriggerContext<TArgs, TReturn> = {\n      index: 0,\n      length: this.#items.sorted.length,\n      args,\n      results,\n      hook: this,\n    };\n    try {\n      if ((await this.intercept(obj => obj.beforeLoop, context)) === false) {\n        return HookCancel;\n      }\n      if (!context.bail) {\n        while (context.index < context.length) {\n          context.hookItem = this.#items.sorted[context.index];\n          if ((await this.intercept(obj => obj.beforeTrigger, context)) === false) {\n            return HookCancel;\n          }\n          if (context.bail) {\n            context.bail = true;\n            break;\n          }\n          const result = await context.hookItem.action(...context.args);\n          if (result === HookCancel) {\n            return HookCancel;\n          }\n          results.push(result);\n\n          context.args = this.getNextArgs(result, context.args);\n          if ((await this.intercept(obj => obj.afterTrigger, context)) === false) {\n            return HookCancel;\n          }\n          if (context.bail || (this.bailOut && this.bailOut(result))) {\n            context.bail = true;\n            break;\n          }\n          context.index++;\n        }\n      }\n      if ((await this.intercept(obj => obj.afterLoop, context)) === false) {\n        return HookCancel;\n      }\n      return this.getMergedResults(results, context.args);\n    } catch (err) {\n      await this.intercept(obj => obj.onError, err, context);\n      throw err;\n    }\n  }\n\n  private async intercept<TArguments extends unknown[]>(\n    method: (\n      interceptor: HookInterceptor<TArgs, TReturn>\n    ) => ((...args: TArguments) => Promise<boolean | void>) | undefined,\n    ...args: TArguments\n  ) {\n    for (const interceptor of this.#interceptors.sorted) {\n      const event = method(interceptor);\n      if (event) {\n        const result = await event.apply(interceptor, args);\n        if (!result) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  public add(...hooks: Array<Hook<TArgs, TReturn, TResult>>): void {\n    for (const hook of hooks) {\n      this.#items.addSortSet(hook.#items);\n      this.#interceptors.addSortSet(hook.#interceptors);\n    }\n  }\n\n  public merge(...hooks: Array<Hook<TArgs, TReturn, TResult>>) {\n    const result = this.initNew();\n    result.#items.addSortSet(this.#items);\n    result.#interceptors.addSortSet(this.#interceptors);\n    result.add(...hooks);\n    return result;\n  }\n\n  protected abstract getNextArgs(next: TReturn, args: TArgs): TArgs;\n\n  protected abstract getMergedResults(results: TReturn[], args: TArgs): TResult;\n\n  protected abstract initNew(): Hook<TArgs, TReturn, TResult>;\n}\n", "import { Hook } from './hook';\n\nexport class LastOutHook<TArgs extends unknown[], TReturn> extends Hook<\n  TArgs,\n  TReturn | undefined,\n  TReturn | undefined\n> {\n  constructor(bailOut?: ((arg: TReturn | undefined) => boolean) | undefined) {\n    super(bailOut);\n  }\n  protected getNextArgs(_next: TReturn | undefined, args: TArgs): TArgs {\n    return args;\n  }\n\n  protected getMergedResults(results: TReturn[]): TReturn | undefined {\n    return results.pop();\n  }\n  protected initNew() {\n    return new LastOutHook<TArgs, TReturn | undefined>(this.bailOut);\n  }\n}\n", "import { Hook } from './hook';\n\nexport class SeriesHook<TArgs extends unknown[], TReturn> extends Hook<TArgs, TReturn, Array<TReturn>> {\n  constructor(bailOut?: ((arg: TReturn) => boolean) | undefined) {\n    super(bailOut);\n  }\n  protected getNextArgs(_next: TReturn, args: TArgs): TArgs {\n    return args;\n  }\n\n  protected getMergedResults(results: TReturn[]): TReturn[] {\n    return results;\n  }\n\n  protected initNew() {\n    return new SeriesHook<TArgs, TReturn>(this.bailOut);\n  }\n}\n", "import { Hook } from './hook';\n\nexport class WaterfallHook<TArgs extends unknown[], TBail = TArgs[0]> extends Hook<\n  TArgs,\n  TArgs[0] | TBail,\n  TArgs[0] | TBail\n> {\n  constructor(bailOut?: ((arg: TArgs[0] | TBail) => boolean) | undefined) {\n    super(bailOut);\n  }\n  protected getNextArgs(next: TArgs[0], args: TArgs): TArgs {\n    args[0] = next;\n    return args;\n  }\n\n  protected getMergedResults(results: TArgs[0][], args: TArgs): TArgs[0] {\n    if (results.length > 0) {\n      return results.pop();\n    }\n    return args[0];\n  }\n  protected initNew() {\n    return new WaterfallHook<TArgs, TBail>(this.bailOut);\n  }\n}\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "Hook", "HookCancel", "LastOutHook", "SeriesHook", "WaterfallHook", "__toCommonJS", "HookCancel", "SortSet", "id", "obj", "items", "item", "index", "set", "sortItems", "obj1", "obj2", "sortMap", "beforeItems", "sortItem", "afterId", "afterItem", "beforeId", "beforeItem", "result", "afterIndex", "Hook", "bailOut", "#items", "SortSet", "#interceptors", "id", "action", "options", "item", "getAction", "objs", "obj", "args", "interceptor", "results", "context", "HookCancel", "result", "err", "method", "event", "hooks", "hook", "LastOutHook", "_LastOutHook", "Hook", "bailOut", "_next", "args", "results", "SeriesHook", "_SeriesHook", "Hook", "bailOut", "_next", "args", "results", "WaterfallHook", "_WaterfallHook", "Hook", "bailOut", "next", "args", "results"]
}
